[id="camel-quarkus-cxf-testing-guide"]
= Testing Camel Quarkus Extensions

Testing offers a good way to ensure Camel routes behave as expected over time. If you haven't already, read the xref:user-guide/first-steps.adoc[First Steps] and https://quarkus.io/guides/getting-started-testing[Quarkus testing] sections.

When it comes to testing a route in the context of Quarkus, the recommended approach is to write local integration tests.
This has the advantage of covering both JVM and native mode.

In JVM mode, you can use the xref:#_cameltestsupport_style_of_testing[`CamelTestSupport`] style testing can also be used.

== Running in JVM mode

In JVM mode, use the `@QuarkusTest` annotation to bootstrap Quarkus and start Camel routes _before_ the `@Test` logic executes.

For example:

[source,java]
----

import io.quarkus.test.junit.QuarkusTest;
import org.junit.jupiter.api.Test;

@QuarkusTest
class MyTest {
    @Test
    public void test() {
        // Use any suitable code that sends test data to the route and then assert outcomes
        ...
    }
}
----

[TIP]
====
You can find a sample implementation in the Camel Quarkus source:

* link:https://github.com/apache/camel-quarkus/blob/main/integration-tests/bindy/src/test/java/org/apache/camel/quarkus/component/bindy/it/MessageTest.java[MessageTest.java]
====

[[native-tests]]
== Running in native mode

[NOTE]
====
Always test that your application works in native mode for all supported extensions.
====

You can reuse the test logic defined for JVM mode by inheriting the logic from the respective JVM mode class.

Add the `@QuarkusIntegrationTest` annotation to tell the Quarkus JUnit extension to compile the application under test to native image and start it before running the tests.

[source,java]
----
import io.quarkus.test.junit.QuarkusIntegrationTest;

@QuarkusIntegrationTest
class MyIT extends MyTest {
   ...
}
----

[TIP]
====
You can find a sample implementation in the Camel Quarkus source:

* link:https://github.com/apache/camel-quarkus/blob/main/integration-tests/bindy/src/test/java/org/apache/camel/quarkus/component/bindy/it/MessageRecordIT.java[MessageRecordIT.java]
====

[[jvm-vs-native-tests]]
== Differences between `@QuarkusTest` and `@QuarkusIntegrationTest`

A native executable does not need a JVM to run, and cannot run in a JVM, because it is native code, not bytecode.

There is no point in compiling tests to native code so they run using a traditional JVM.

This means that communication between tests and the application must go over the network (HTTP/REST, or any other protocol your application speaks), through watching filesystems (log files for example), or any other interprocess communication.

=== `@QuarkusTest` in JVM mode

In JVM mode, tests annotated with `@QuarkusTest` execute in the same JVM as the application under test.

This means you can use `@Inject` to add beans from the application into the test code.

You can also define new beans or even override the beans from the application using `@javax.enterprise.inject.Alternative` and `@javax.annotation.Priority`.

=== `@QuarkusIntegrationTest` in native mode

In native mode, tests annotated with `@QuarkusIntegrationTest` execute in a JVM hosted in a process separate from the running native application.

An important consequence of this, is that all communication between the tests and the native application,
must take one or more of the following forms:

* Network calls. Typically, HTTP or any other network protocol your application supports.
* Watching the filesystem for changes. (For example via Camel `file` endpoints.)
* Any other kind of interprocess communication.

`QuarkusIntegrationTest` provides additional features that are not available through `@QuarkusTest`:

* In JVM mode, you can launch and test the runnable application JAR produced by the Quarkus build.
* In native mode, you can launch and test the native application produced by the Quarkus build.
* If you add a container image to the build, a container starts, and tests execute against it.

For more information about `QuarkusIntegrationTest`, see the link:https://quarkus.io/guides/getting-started-testing#quarkus-integration-test[Quarkus testing guide].

== Testing with external services

=== Testcontainers

Sometimes your application needs to access some external resource, such as a messaging broker, a database, or other service.

If a container image is available for the service of interest, you can use  https://www.testcontainers.org/[Testcontainers] to start and configure the services during testing.

==== Passing configuration data with `QuarkusTestResourceLifecycleManager`

For the application to work properly, it is often essential to pass the connection configuration data (host, port, user, password of the remote service) to the application before it starts.

In the Quarkus ecosystem, `QuarkusTestResourceLifecycleManager` serves this purpose.

You can start one or more Testcontainers in the `start()` method and return the connection configuration from the method in the form of a `Map`.

The entries of this map are then passed to the application in different ways depending on the mode:

* Native mode:  a command line (`-Dkey=value`)
* JVM Mode: a special MicroProfile configuration provider

[NOTE]
====
Command line and MicroProfile settings have a higher precedence than the settings in the `application.properties` file.
====

[source,java]
----
import java.util.Map;
import java.util.HashMap;

import io.quarkus.test.common.QuarkusTestResourceLifecycleManager;
import org.testcontainers.containers.GenericContainer;
import org.testcontainers.containers.wait.strategy.Wait;

public class MyTestResource implements QuarkusTestResourceLifecycleManager {

    private GenericContainer<?> myContainer;

    @Override
    public Map<String, String> start() {
        // Start the needed container(s)
        myContainer = new GenericContainer(DockerImageName.parse("my/image:1.0.0"))
                .withExposedPorts(1234)
                .waitingFor(Wait.forListeningPort());

        myContainer.start();

        // Pass the configuration to the application under test
        // You can also pass camel component property names / values to automatically configure Camel components
        return new HashMap<>() {{
                put("my-container.host", container.getHost());
                put("my-container.port", "" + container.getMappedPort(1234));
        }};
    }

    @Override
    public void stop() {
        // Stop the needed container(s)
        myContainer.stop();
        ...
    }
}
----

Reference the defined test resource from the test classes with `@QuarkusTestResource`:

[source,java]
----
import io.quarkus.test.common.WithTestResource;
import io.quarkus.test.junit.QuarkusTest;

@QuarkusTest
@WithTestResource(MyTestResource.class)
class MyTest {
   ...
}
----

[TIP]
====
You can find a sample implementation in the Camel Quarkus source:

* https://github.com/apache/camel-quarkus/blob/main/integration-tests/nats/src/test/java/org/apache/camel/quarkus/component/nats/it/NatsTestResource.java[NatsTestResource.java]
====

=== WireMock

Instead of having the tests connect to live endpoints, for example, if they are unavailable, unreliable, or expensive, you can stub HTTP interactions with third-party services & APIs.

You can use link:https://wiremock.org/[WireMock] for mocking & recording HTTP interactions. It is used extensively throughout the Camel Quarkus test suite for various component extensions.

==== Setting up WireMock

.Procedure
. Set up the WireMock server.
+
[NOTE]
====
Always configure the Camel component under test to pass any HTTP interactions through the WireMock proxy. You can achieve this by configuring a component property that determines the API endpoint URL.
====
+
[source,java]
----
import static com.github.tomakehurst.wiremock.client.WireMock.aResponse;
import static com.github.tomakehurst.wiremock.client.WireMock.get;
import static com.github.tomakehurst.wiremock.client.WireMock.urlEqualTo;
import static com.github.tomakehurst.wiremock.core.WireMockConfiguration.wireMockConfig;

import java.util.HashMap;
import java.util.Map;

import com.github.tomakehurst.wiremock.WireMockServer;

import io.quarkus.test.common.QuarkusTestResourceLifecycleManager;

public class WireMockTestResource implements QuarkusTestResourceLifecycleManager {

    private WireMockServer server;

    @Override
    public Map<String, String> start() {
        // Setup & start the server
        server = new WireMockServer(
            wireMockConfig().dynamicPort()
        );
        server.start();

        // Stub an HTTP endpoint. WireMock also supports a record and playback mode
        // https://wiremock.org/docs/record-playback/
        server.stubFor(
            get(urlEqualTo("/api/greeting"))
                .willReturn(aResponse()
                    .withHeader("Content-Type", "application/json")
                    .withBody("{\"message\": \"Hello World\"}")));

        // Ensure the camel component API client passes requests through the WireMock proxy
        Map<String, String> conf = new HashMap<>();
        conf.put("camel.component.foo.server-url", server.baseUrl());
        return conf;
    }

    @Override
    public void stop() {
        if (server != null) {
            server.stop();
        }
    }
}
----
+
. Ensure your test class has the `@WithTestResource` annotation with the appropriate test resource class specified as the value. The WireMock server will be started before all tests are
executed and will be shut down when all tests are finished.

[source,java]
----
import io.quarkus.test.common.WithTestResource;
import io.quarkus.test.junit.QuarkusTest;

@QuarkusTest
@WithTestResource(WireMockTestResource.class)
class MyTest {
   ...
}
----

The WireMock server starts before all tests execute and shuts down when all tests finish.

[TIP]
====
You can find a sample implementation in the Camel Quarkus integration test source tree:

* link:https://github.com/apache/camel-quarkus/tree/main/integration-tests/geocoder[Geocoder].
====

[[cameltestsupport_style_of_testing]]
== `CamelTestSupport` style of testing with `CamelQuarkusTestSupport`

Since Camel Quarkus 2.13.0, you can use `CamelQuarkusTestSupport` for testing. It is a replacement for `CamelTestSupport`, which does not work well with Quarkus.

[IMPORTANT]
====
`CamelQuarkusTestSupport` only works in JVM mode. If you need to test in native mode, then use one of the alternate test strategies described above.
====


=== Testing with `CamelQuarkusTestSupport` in JVM mode

Add the following dependency into your module (preferably in the `test` scope):

[source,xml]
----
<dependency>
    <groupId>org.apache.camel.quarkus</groupId>
    <artifactId>camel-quarkus-junit5</artifactId>
    <scope>test</scope>
</dependency>
----

You can use `CamelQuarkusTestSupport` in your test like this:

[source,java]
----
@QuarkusTest
@TestProfile(SimpleTest.class) //necessary only if "newly created" context is required for the test (worse performance)
public class SimpleTest extends CamelQuarkusTestSupport {
    ...
}
----

=== Customizing the `CamelContext` for testing

You can customize the `CamelContext` for testing with https://quarkus.io/guides/config-reference#profiles[configuration profiles], CDI beans, observers, https://quarkus.io/guides/getting-started-testing#mock-support[mocks] etc.
You can also override the `createCamelContext` method and interact directly with the `CamelContext`.

[IMPORTANT]
====
When using `createCamelContext` you *MUST NOT*  instantiate and return a new `CamelContext`. Instead, invoke `super.createCamelContext()` and modify the returned `CamelContext` as needed.
Failing to follow this rule will result in an exception being thrown.
====

[source,java]
----
@QuarkusTest
class SimpleTest extends CamelQuarkusTestSupport {

    @Override
    protected CamelContext createCamelContext() throws Exception {
        // Must call super to get a handle on the application scoped CamelContext
        CamelContext context = super.createCamelContext();
        // Apply customizations
        context.setTracing(true);
        // Return the modified CamelContext
        return context;
    }
}
----

=== Configuring routes for testing

Any classes that extend `RouteBuilder` in your application will have their routes automatically added to the `CamelContext`.
Similarly, any XML or YAML routes configured from `camel.main.routes-include-pattern` will also be loaded.

This may not always be desirable for your tests.
You control which routes get loaded at test time with configuration properties:

* `quarkus.camel.routes-discovery.include-patterns`
* `quarkus.camel.routes-discovery.exclude-patterns`,
* `camel.main.routes-include-pattern`
* `camel.main.routes-exclude-pattern`.

You can also define test specific routes per test class by overriding `createRouteBuilder`:

[source,java]
----
@QuarkusTest
class SimpleTest extends CamelQuarkusTestSupport {
    @Test
    void testGreeting() {
        MockEndpoint mockEndpoint = getMockEndpoint("mock:result");
        mockEndpoint.expectedBodiesReceived("Hello World");

        template.sendBody("direct:start", "World");

        mockEndpoint.assertIsSatisified();
    }

    @Override
    protected RoutesBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            @Override
            public void configure() throws Exception {
                from("direct:start")
                    .transform().simple("Hello ${body}")
                    .to("mock:result");
            }
        };
    }
}
----

=== CamelContext test lifecycle

One of the main differences in `CamelQuarkusTestSupport` compared to `CamelTestSupport` is how the `CamelContext` lifecycle is managed.

On Camel Quarkus, a single `CamelContext` is created for you automatically by the runtime.
By default, this `CamelContext` is shared among all tests and remains started for the duration of the entire test suite execution.

This can potentially have some unintended side effects for your tests.
If you need to have the `CamelContext` restarted between tests, then you can create a custom https://quarkus.io/guides/getting-started-testing#testing_different_profiles[test profile], which will force the application under test to be restarted.

For example, to define a test profile:

[source,java]
----
@QuarkusTest
class MyTestProfile implements QuarkusTestProfile {
    ...
}
----

Then reference it on the test class with `@TestProfile`:

[source,java]
----
// @TestProfile will trigger the application to be restarted
@TestProfile(MyTestProfile.class)
@QuarkusTest
class SimpleTest extends CamelQuarkusTestSupport {
    ...
}
----

[NOTE]
====
You cannot manually restart the `CamelContext` by invoking its `stop()` and `start()` methods. This will result in an exception.
====

=== Examples

==== Simple `RouteBuilder` and test class

Simple `RouteBuilder`:

[source,java]
----
public class MyRoutes extends RouteBuilder {
    @Override
    public void configure() {
        from("direct:start")
            .transform().simple("Hello ${body}")
            .to("mock:result");
    }
}
----

Test sending a message payload to the `direct:start` endpoint:

[source,java]
----
@QuarkusTest
class SimpleTest extends CamelQuarkusTestSupport {
    @Test
    void testGreeting() {
        MockEndpoint mockEndpoint = getMockEndpoint("mock:result");
        mockEndpoint.expectedBodiesReceived("Hello World");

        template.sendBody("direct:start", "World");

        mockEndpoint.assertIsSatisified();
    }
}
----

==== Using `AdviceWith`

[source,java]
----
@QuarkusTest
class SimpleTest extends CamelQuarkusTestSupport {
    @BeforeEach
    public void beforeEach() throws Exception {
        AdviceWith.adviceWith(this.context, "advisedRoute", route -> {
            route.replaceFromWith("direct:replaced");
        });
    }

    @Override
    protected RoutesBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            @Override
            public void configure() throws Exception {
                from("direct:start").routeId("advisedRoute")
                    .transform().simple("Hello ${body}")
                    .to("mock:result");
            }
        };
    }

    @Test
    void testAdvisedRoute() throws Exception {
        MockEndpoint mockEndpoint = getMockEndpoint("mock:result");
        mockEndpoint.expectedBodiesReceived("Hello World");

        template.sendBody("direct:replaced", "World");

        mockEndpoint.assertIsSatisfied();
    }
}
----

==== Explicitly enabling advice

When explicitly xref:manual::advice-with.adoc#_enabling_advice_during_testing[enabling advice] you must invoke `startRouteDefinitions` when completing your `AdviceWith` setup.

[NOTE]
====
Invoking `startRouteDefinitions` is only required if you have routes configured that are *NOT* being advised.
====

=== Limitations

==== Test lifecycle methods inherited from `CamelTestSupport`

`CamelQuarkusTestSupport` inherits some test lifecycle methods from `CamelTestSupport`. However, they should not be used and instead are replaced with equivalent methods in `CamelQuarkusTestSupport`.

|===
|CamelTestSupport lifecycle methods |CamelQuarkusTestSupport equivalent

|`afterAll`
|`doAfterAll`

|`afterEach`, `afterTestExecution`
|`doAfterEach`

|`beforeAll`
|`doAfterConstruct`

|`beforeEach`
|`doBeforeEach`
|===

==== Creating a custom Camel registry is not supported

The `CamelQuarkusTestSupport` implementation of `createCamelRegistry` will throw `UnsupportedOperationException`.

If you need to bind or unbind objects to the Camel registry, then you can do it by one of the following methods.

* Produce named CDI beans
+
[source,java]
----
public class MyBeanProducers {
    @Produces
    @Named("myBean")
    public MyBean createMyBean() {
        return new MyBean();
    }
}
----
+
* Override `createCamelContext` (see example above) and invoke `camelContext.getRegistry().bind("foo", fooBean)`
* Use the `@BindToRegistry` annotation
+
[source,java]
----
@QuarkusTest
class SimpleTest extends CamelQuarkusTestSupport {
    @BindToRegistry("myBean")
    MyBean myBean = new MyBean();
}
----
+
[NOTE]
====
Beans bound to the Camel registry from individual test classes, will persist for the duration of the test suite execution.
This could have unintended consequences, depending on your test expectations. You can use test profiles to restart the `CamelContext` to avoid this.
====